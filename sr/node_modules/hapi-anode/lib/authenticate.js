'use strict';

var assert = require('assert'),
    querystring = require('querystring'),
    ask = require('./ask-server'),
    url = require('url'),
    _ = require('lodash');

var SESSION_CREDS_KEY = '_anode',
    TOKEN_TIMEOUT = 10 * 1000;

function fixURLpath(baseURL, pathname, query) {
    var parts = url.parse(baseURL);
    delete parts.href;
    delete parts.path;
    parts.pathname = pathname;
    parts.query = query;
    return url.format(parts);
}

/* For Reference
    Shape of an AuthNode bearer token (decrypted):
    ** safeUserAtts (see: onDetail) is info.atts

    {
    user_id: "<redacted_user_id>"
    client_id: "sr"
    expires: 1414522088235
    expired: false
    info: {
        uid: "<redacted_user_id>"
        atts: {
                agreementtype: ""
                certified: ""
                cmat_list: ""
                companycountry: "US"
                companyid: ""
                companyname: "Network Appliance, Inc"
                company_entitlement: "Master"
                compjderefnumber: ""
                connection: "keep-alive"
                contact_entitlement: "Master"
                cookie: "<redacted_ntap_sso_cookie>"
                crmcompanyid: "82678"
                crmcontactid: ""
                crmcustlist: ""
                crmcustomertype: "NULL"
                crmlogin: "<redacted_user_id>" // All Upper Case
                crmloginalias: "<redacted_user_id>"
                crmsiteid: "<redacted_crm_site_id>"
                customertype: "NULL"
                customer_list: ""
                department: ""
                ecid_context: "1.0051bxQCB4tEwGkLky_AiZ0001Is0000Vp;kXjE1ZDLIPJIj3RPdTAOdURB_UQT^LTRkUBObPO"
                employee_id: ""
                employee_username: ""
                firstname: "<redacted_first_name>"
                fullname: "<redacted_full_name>"
                host: "signin.netapp.com"
                is_ssl: "ssl"
                lastname: "<redacted_last_name>"
                login: "<redacted_user_id>"
                mail: "<redacted_email_address>"
                netmarketacl: ""
                netmarketenabled: ""
                nowenabled: "1"
                oam_remote_user: "<redacted_user_id>"
                oempartner: ""
                partnertype: ""
                secure_company: ""
                secure_person: ""
                se_pilot_customer: ""
                sitecountry: ""
                siteid: "88483"
                sitejderefnumber: ""
                sitename: "NetApp-Sunnyvale-495 E Java Dr Bldg 10"
                site_entitlement: "Master"
                sm_user: "<redacted_user_id>"
                sm_userdn: "uid=<redacted_user_id>,ou=internal,o=netapp.com"
                sm_usersessionid: "<redacted_user_id>"
                title: "Software Engineer"
                uid: "<redacted_user_id>"
                user_role: ""
                vanlogin: ""
                vanpersonid: "<redacted_hr_id>"
                vipenabled: ""
                _type: "employee" // Also contractor, partner, customer
                _source: "pdb" // Also envdump
                pdbentitlements: "synergy_base,teso_eGen,teso_cmpg"
            }
        }
    }
*/

/**
 * @class AnodeWorker
 * @constructor
 * @desc Implements a [Hapi scheme] for a given server and auth strategy
 *
 * [Hapi scheme]: https://github.com/spumko/hapi/blob/master/docs/Reference.md#serverauthschemename-scheme
 * @param server {object} - the Hapi server
 * @param options {object} - the strategy options == the plugin options
 * @param request {object} - the request
 * @param reply {object} - the function used to reply
 */

function AnodeWorker(server, options, request, reply) {
    assert(this instanceof AnodeWorker, 'use new');
    assert(typeof(server) === 'object', 'server not object');
    assert(typeof(options) === 'object', 'options not object');
    assert(typeof(request) === 'object', 'request not object');
    assert(typeof(reply) === 'function', 'reply not function');
    assert(options.sessionSecs > 60, 'options.sessionSecs unreasonable');

    this.options = options;
    if (server.app.redirect_uri_base) {
        this.options.redirect_uri_base = server.app.redirect_uri_base;
    }
    this.request = request;
    this.reply = reply;
    this.ask = ask.bind(null, request.log.bind(request));
}

AnodeWorker.prototype.log = function (extraTags, info) {
    var tags = [ 'auth' ];
    assert(extraTags instanceof Array || arguments.length === 1);

    if (extraTags instanceof Array) {
        extraTags.forEach(function(tag) {
            if (tags.indexOf(tag) < 0) {
                tags.push(tag);
            }
        });
    } else {
        info = extraTags; // shift argument
    }

    if (typeof(info) === 'string') {
        info = { what: info };
    }

    info.session = this.request.session.id;
    this.request.log(tags, info);
};

AnodeWorker.prototype.fail = function fail(err) {
    this.log(['error'], err);
    setImmediate(this.reply, null, err);
};

AnodeWorker.prototype.succeed = function succeed(creds) {
    this.log(['success'], { what: 'authenticated', user: creds.credentials.user });
    setImmediate(this.reply.continue.bind(this.reply), creds);
};

AnodeWorker.prototype.authenticate = function authenticate() {
    if (this.request.query && this.request.query.code) {
        return this.exchangeCodeForToken();
    } else {
        return this.trySessionOrRedirect();
    }
};

function censorForm(form) {
    // jshint camelcase: false
    form.client_secret = '...';
    form.code = form.code.slice(0, 8) + '...' + form.code.slice(form.code.length - 8);
}

AnodeWorker.prototype.exchangeCodeForToken = function CFAC() {
    var creds = this.request.session.get(SESSION_CREDS_KEY),
        what = 'request has authorization code';

    if (creds === false) {
        this.log({ what: what, cookies: 'present', credentials: 'absent' });
    } else if (creds === undefined) {
        this.log(['unexpected'], { what: what, cookies: 'absent' });
    } else {
        this.log(['unexpected'], { what: what, cookies: 'present', credentials: 'present' });
    }

    var form = this.makeTokenForm(this.request.query.code),
        formData = querystring.stringify(form),
        tokenURL = this.makeTokenURL(),
        options = {
            payload: formData,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': formData.length,
            },
            rejectUnauthorized: !this.options.insecure,
            agent: null,
            timeout: TOKEN_TIMEOUT,
        };

    censorForm(form);
    this.log({
        what: 'exchanging authorization code for token',
        form: form
    });
    this.ask('access token', 'POST', tokenURL, options, this.onToken.bind(this));
};

AnodeWorker.prototype.makeTokenForm = function makeTokenForm(code) {
    // jshint camelcase: false
    return {
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: this.options.redirect_uri_base,
        client_id: this.options.client_id,
        client_secret: this.options.client_secret,
    };
};

AnodeWorker.prototype.makeTokenURL = function makeTokenURL() {
    return fixURLpath(this.options.server, this.options.paths.token);
};

AnodeWorker.prototype.makeUserDetailsURL = function makeUserDetailsURL() {
    return fixURLpath(this.options.server, this.options.paths.userDetails);
};

AnodeWorker.prototype.onToken = function onToken(err, parsed) {
    // jshint camelcase: false

    if (err) {
        return this.fail(err);
    }

    if (!parsed.access_token) {
        return this.fail(new Error('token response lacks access_token'));
    }

    this.log('server granted access token');
    this.token = parsed.access_token;

    this.getUserDetails();
};

AnodeWorker.prototype.getUserDetails = function GUD() {
    var uri = this.makeUserDetailsURL(),
        options = {
            headers: {
                'Authorization': 'Bearer ' + this.token,
            },
            rejectUnauthorized: !this.options.insecure,
            agent: null,
        };

    this.ask('user details', 'GET', uri, options, this.onDetails.bind(this));
};

AnodeWorker.prototype.onDetails = function onDetails(err, parsed) {
    // jshint camelcase: false

    if (err) {
        return this.fail(err);
    }

    this.log({
        what: 'user details received',
        details: parsed,
    });

    var safeUserInfo = parsed.info || {},
        safeUserAtts = safeUserInfo.user_atts || {},
        result = {
            credentials: {
                user: parsed.user_id,
                userType: safeUserAtts._type,
                firstName: safeUserAtts.firstname,
                lastName: safeUserAtts.lastname,
                companyName: safeUserAtts.companyname,
                serverTime: safeUserAtts.servertime,
                expires: Date.now() + 1000 * this.options.sessionSecs,
            },
            artifacts: {
                token: this.token
            }
        };

    var baseURL = this.options.redirect_uri_base,
        prURL = this.request.url,
        query = _.omit(prURL.query, 'code'),
        target = fixURLpath(baseURL, prURL.pathname, query);

    if (this.isUserTypeAuthorized(result.credentials.userType)) {
        this.request.session.set(SESSION_CREDS_KEY, result);

        this.log({
            what: 'authentication complete; redirecting back...',
            user: parsed.user_id,
            target: target
        });
        this.reply('authentication complete; redirecting you back...')
            .redirect(target);
    }
    else {
        this.log({
            what: 'access for user blocked due to user type: ' + result.credentials.userType,
            user: result.credentials.user,
            target: target
        });

        this.request.session.clear(SESSION_CREDS_KEY);
        this.fail('Access is not allowed for user type ' + result.credentials.userType);
    }
};

AnodeWorker.prototype.isUserTypeAuthorized = function isUserTypeAuthorized(userType) {
    if (userType) {
        if (this.options.access) {
            var accessOptions = this.options.access;

            if (accessOptions) {
                if (userType === 'customer') {
                    return accessOptions.allow_customer;
                }
            }
        }
    }

    return true; // By default, yes
};


AnodeWorker.prototype.trySessionOrRedirect = function CFCS() {
    var creds = this.getUnexpiredCredsFromSession();
    if (creds) {
        this.succeed(creds);
    } else {
        this.redirectToAuthenticationServer();
    }
};

AnodeWorker.prototype.getUnexpiredCredsFromSession = function GUCFS() {
    var result = this.request.session.get(SESSION_CREDS_KEY);

    if (result) {
        if (result.credentials.expires < Date.now()) {
            this.log(['session', 'warning'], {
                user: result.credentials.user,
                what: 'session expired'
            });
            this.request.session.clear(SESSION_CREDS_KEY);
            return null;
        } else {
            // deliberately not logging the normal case of user having
            // current credentials
        }
    } else {
        this.log([ 'session', 'warning' ], {
            what: 'no credentials found'
        });
    }

    return result;
};

AnodeWorker.prototype.redirectToAuthenticationServer = function RTAS() {
    this.request.session.set(SESSION_CREDS_KEY, false); // cookie check
    this.log('redirecting to OAUTH2 server');
    this.reply('redirecting you for authentication...')
        .redirect(this.makeResponseTypeCodeURL());
};

AnodeWorker.prototype.makeResponseTypeCodeURL = function MRTCU() {
    var prURL = this.request.url,
        options = this.options; // pre-parsed by Hapi

    // jshint camelcase: false
    var baseURL = options.redirect_uri_base,
        redirectURL = fixURLpath(baseURL, prURL.pathname, prURL.query);

    return fixURLpath(options.server, 'auth', {
        response_type: 'code',
        client_id: options.client_id,
        redirect_uri: redirectURL,
        scope: options.scope || '-',
    });
};

function scheme(server, options) {
    server.log(['auth', 'registration', 'strategy'], 'strategy used scheme: known');
    server.log(['auth', 'registration', 'strategy'], { options: options });

    return {
        authenticate: function authenticate(request, reply) {
            var worker;
            try {
                worker = new AnodeWorker(server, options, request, reply);
                return worker.authenticate();
            } catch (err) {
                return reply(err);
            }
        }
    };
}

module.exports = scheme;
