'use strict';

var assert = require('assert'),
    hgstale = require('./hgstale'),
    path = require('path'),
    fs = require('fs'),
    async = require('async'),
    domain = require('domain'),
    gutil = require('gulp-util'),
    _ = require('lodash');

// return the link target, or the original filename if not a link
// follows links to links until the final destination
// calls back with null, null if a link can't be followed
function followLinkTarget(possibleLink, callback) {
    function errIndicatesPathWasNotALink (err) {
        if (!err) {
            return true;
        } else if (err.code === 'EINVAL') {
            return true; // not really a link (UNIX)
        } else if (err.code === 'UNKNOWN' && process.platform === 'win32') {
            return true; // not really a link (Windows)
        } else {
            return false;
        }
    }

    function withLinkTarget(err, target) {
        if (err) {
            if (errIndicatesPathWasNotALink(err)) {
                return setImmediate(callback, null, possibleLink);
            } else {
                return setImmediate(callback, null, null);
            }
        } else {
            try {
                var absTarget = path.resolve(path.dirname(possibleLink), target);
                return setImmediate(followLinkTarget, absTarget, callback);
            } catch (err) {
                return setImmediate(callback, err);
            }
        }
    }

    fs.readlink(possibleLink, withLinkTarget);
}

function reprfilename(filename) {
    var relative = path.relative(process.cwd(), filename);
    return gutil.colors.magenta(relative);
}

function checkDepLinks(warn, root, done) {
    assert(typeof(warn) === 'function');
    assert(typeof(root) === 'string');
    assert(typeof(done) === 'function');

    done = _.once(done);

    var checkDomain = domain.create();

    function fail(err) {
        checkDomain.dispose();
        return done(err);
    }

    checkDomain.once('error', fail);

    function checkModule(modulePath, callback) {
        assert(typeof(modulePath) === 'string');
        assert(typeof(callback) === 'function');

        function withModuleTarget(target) {
            assert(typeof(target) === 'string' || target === null);

            if (target === root) {
                // ignore link back to self
                return setImmediate(callback, null);
            }

            if (target === null) {
                warn(reprfilename(modulePath) + ' couldn\'t be resolved');
                return setImmediate(callback, null);
            }

            if (modulePath === target) {
                return setImmediate(callback, null);
            } else {
                hgstale(modulePath, function (err, stale) {
                    var link = reprfilename(modulePath);
                    if (err && err.message === hgstale.NOT_IN_REPO) {
                        warn(link + ' is a link to a stale directory');
                    } else if (err) {
                        fail(err);
                    } else if (stale) {
                        warn(link + ' is a link to a stale repository');
                    } else {
                        warn(link + ' is a link');
                    }

                    return setImmediate(checkDepLinks, warn, fs.realpathSync(modulePath), callback);
                });
            }
        }

        followLinkTarget(modulePath, checkDomain.intercept(withModuleTarget));
    }

    function withFiles(files) {
        var modulePaths = [];
        files.forEach(function(file) {
            if (file !== '.bin') {
                modulePaths.push(path.join(root, 'node_modules', file));
            }
        });

        async.each(modulePaths, checkModule, done);
    }

    fs.readdir(path.join(root, 'node_modules'), checkDomain.intercept(withFiles));
}

module.exports = _.curry(checkDepLinks);
