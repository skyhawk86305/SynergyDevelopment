#!/usr/bin/env node
'use strict';

var assert = require('assert'),
    async = require('async'),
    glue = require('glue'),
    url = require('url'),
    util = require('util'),
    path = require('path'),
    fs = require('fs'),
    ansi = require('ansi'),
    events = require('events'),
    _ = require('lodash');

var DEFAULT_MANIFEST = {
        servers: [ {
            port: 8000,
            options: {
                cors: true
            }
        } ]
    };

function dirOrDefault(dir) {
    return path.normalize((dir || process.env.PWD || process.cwd()));
}

function subPath(parent, name) {
    return path.join(dirOrDefault(parent), name);
}

function BenchTest(options) {
    assert(this instanceof BenchTest, 'use new');
    events.EventEmitter.call(this);

    this.options = options || {};
    this.debug = process.env.BENCHTEST_DEBUG || this.options.debug;
    this.ansi = ansi(process.stderr);
    this.log = this.log.bind(this);
    this.home = dirOrDefault(this.options.home);

    assert(!this.options.hapi, 'overriding hapi no longer supported');

    _.forEach([ 'fatal', 'error', 'warning' ], _.partial(sublog, this.log));

    // You'll read "bind is slow". lodash.bind is faster. The introspection
    // in Mocha beforeEach and afterEach to detect callbacks breaks if we
    // use lodash.bind. So, we're using the builtin.
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
}
util.inherits(BenchTest, events.EventEmitter);

function sublog(logfn, level) {
    logfn[level] = function (tags, data) {
        tags = (tags || []).slice(0);
        tags.push(level);
        return logfn(tags, data);
    };
}

function getColor(tags) {
    tags = tags || [];

    var result = null,
        map = [ // put most severe LAST
            [ 'warning', 'yellow' ],
            [ 'error', 'red' ],
            [ 'fatal', 'brightRed' ],
        ];

    _.forEach(map, function (pair) {
        if (_.contains(tags, pair[0])) {
            result = pair[1];
        }
    });

    return result;
}

BenchTest.prototype.log = function log(tags, data) {
    var col = getColor(tags) || 'grey';

    if (this.options.logFilter && !this.options.logFilter(tags, data)) {
        return;
    }

    if (tags && process.stderr.isTTY) {
        this.ansi
            [col]()
            .write(tags.join(', '));
        if (data) {
            this.ansi.write(': ').reset();
        } else {
            this.ansi.reset().write('\n');
        }
    }

    if (process.stderr.isTTY) {
        if (typeof(data) === 'string') {
            this.ansi.write(data).write('\n');
        } else if (data) {
            this.ansi.write(util.inspect(data, { depth: null, colors: true })).write('\n');
        }
    } else {
        this.ansi.write(JSON.stringify([ tags, data ])).write('\n');
    }
};

function getPackageDetail(packagePath) {
    var packageExists = fs.existsSync(packagePath);

    if (packageExists) {
        return require(packagePath);
    } else {
        return null;
    }
}

BenchTest.prototype.manifestOrDefault = function manifestOrDefault() {
    var packagePath = subPath(this.home, 'package.json'),
        packageDetails = getPackageDetail(packagePath),
        packageName = packageDetails.name,
        manifestPath = subPath(this.home, 'manifest.json'),
        manifestExists = fs.existsSync(manifestPath),
        logTags = ['bench', 'manifest'],
        manifest;

    if (manifestExists) {
        this.log(logTags, 'loading: ' + manifestPath);
        manifest = require(manifestPath);
    } else {
        this.log(logTags, 'missing: ' + manifestPath);
        manifest = DEFAULT_MANIFEST;
        this.log(['bench', 'manifest', 'default'], manifest);
    }

    var noPlugins = Object.keys(manifest.plugins || []).length === 0,
        logManifest = false;

    if (noPlugins && packageName !== 'hapi-bench-test') {
        this.log(logTags, 'inserting default plugin: ' + packageName);
        manifest.plugins = { };
        manifest.plugins[this.home] = { };
        manifest.connections.forEach(function (connection) {
            if (!connection.labels) {
                connection.labels = [ packageName ];
            }
        });
        logManifest = true;
    } else if (noPlugins) {
        manifest.plugins = [];
    } else {
        if (manifest.plugins[packageName]) {
            this.log(logTags, 'fixing local plugin path to: ' + this.home);
            manifest.plugins[this.home] = manifest.plugins[packageName];
            delete manifest.plugins[packageName];
            logManifest = true;
        }
    }

    if (this.debug) {
        this.log(logTags, { newManifest: manifest });
    }

    return manifest;
};

BenchTest.prototype.hookServerEvents = function hookServerEvents(server, next) {
    var self = this;

    server.on('log', function (details, tags) {
        self.log(_.keys(tags), details.data);
        self.emit('log', details, tags);
    });

    server.on('request', function (request, details, tags) {
        self.log(_.keys(tags), details.data);
        self.emit('request', request, details, tags);
    });

    server.on('request-internal', function (request, details, tags) {
        self.log(_.keys(tags), details.data);
        self.emit('request-internal', request, details, tags);
    });

    server.on('response', function (request, details, tags) {
        //self.log(_.keys(tags), details.data);
        self.emit('response', request, details, tags);
    });

    server.on('request-error', function (request, details, tags) {
        self.log(_.keys(tags), details.data);
        self.emit('request-error', request, details, tags);
    });
    next();
};

BenchTest.prototype.logRoutes = function logRoutes(server) {
    var log = this.log,
        tags = [ 'bench', 'route' ],
        connInfo = server.table();

    assert(connInfo.length > 0, 'no connections');

    var routes = connInfo[0].table;

    if (server.info.port) {
        tags.push(server.info.port);
    }

    if (!routes.length) {
        log.warning(tags, 'no routes for: ' + connInfo[0].info.uri);
    } else {
        routes.forEach(function (route) {
            log(tags, route.path);
        });
    }
};

BenchTest.prototype.start = function start(callback) {
    var manifest = this.options.manifest || this.manifestOrDefault(),
        alterations = {},
        self = this,
        relativeTo = path.join(self.home, 'node_modules');

    manifest = getManifestUpdatesFromEnvironment(manifest, alterations);
    if (_.keys(alterations).length) {
        this.log(['bench', 'manifest-envars'], alterations);
    }

    this.log(['bench', 'versions'], {
        hapi: require('hapi/package.json').version,
        glue: require('glue/package.json').version,
    });

    this.log(['bench', 'paths'], {
        home: this.home,
        relativeTo: relativeTo,
    });

    async.waterfall([
        function checkRedis(cb) {
            self.switchCatboxToRedisIfAvailable(manifest, relativeTo, cb);
        },

        function compose(cb) {
            self.log(['bench'], 'glueing server together...');
            try {
                var opts = {
                        relativeTo: relativeTo,
                        prePlugins: self.hookServerEvents.bind(self)
                    };
                glue.compose(manifest, opts, cb);
            } catch (err) {
                cb(err);
            }
        },

        function afterComposition(server, cb) {
            self.logRoutes(server);
            self.server = server;
            self.log(['bench'], 'starting server');
            server.start(cb);
        }
    ], function withResult(err) {
        if (err) {
            self.log(['bench', 'fatal'], err);
        } else {
            self.info = self.server.info;
            self.log(['bench'], 'server started at ' + self.info.uri);
        }
        return callback(err, self.server);
    });
};

function getManifestUpdatesFromEnvironment(manifest, alterations) {
    alterations = alterations || {};
    assert(_.isPlainObject(manifest));
    assert(_.isPlainObject(alterations));
    manifest = _.cloneDeep(manifest);
    fix(manifest, 'manifest');
    return manifest;

    function fix(ob, path) {
        _.forEach(_.keys(ob), function fixValue(key) {
            var value = ob[key];
            switch (typeof value) {
                case 'string':
                    if (value.slice(0, 5) === '$env.') {
                        var envar = value.slice(5),
                            enval = process.env[envar];
                        value = enval || '';
                        ob[key] = value;
                        alterations[path] = value;
                    }
                    break;
                case 'object': // includes arrays
                    fix(value, path + '/' + key);
                    break;
                default:
                    // ignore it
                    break;
            }
        });
    }
}

BenchTest.prototype.switchCatboxToRedisIfAvailable = function SCTRIA(manifest, relativeTo, callback) {
    var TAGS = [ 'bench', 'manifest', 'cache' ],
        self = this;

    if (!( manifest.server &&
           manifest.server.cache &&
           typeof manifest.server.cache.engine === 'string' &&
           manifest.server.cache.engine.indexOf('catbox-memory') >= 0)) {
        this.log([ 'bench', 'manifest', 'cache' ], 'no catbox-memory to override');
        return callback(null);
    }

    var modulePath = path.join(relativeTo, 'catbox-redis'),
        Engine;

    try {
        Engine = require(modulePath);
    } catch (err) {
        this.log(TAGS, 'no catbox-redis; keeping catbox-memory');
        return callback(null);
    }

    this.log(TAGS, 'catbox-redis found; connecting...');
    var engine = new Engine({});
    engine.start(function (err) {
        if (err) {
            self.log(TAGS, 'connection failed; keeping catbox-memory');
        } else {
            engine.stop();
            self.log(TAGS, 'connection succeeded; switching to catbox-redis');
            manifest.server.cache.engine = modulePath;
        }
        callback(null);
    });
};

BenchTest.prototype.stop = function (callback) {
    function onStop(err) {
        // jshint -W040
        this.server = null;
        this.info = null;
        callback(err);
    }

    assert(this.server);
    this.server.stop({ timeout: 5 }, onStop.bind(this));
};

function injectRequest(server, path, next) {
    var argparts = url.parse(path, true),
        parts = {
            protocol: server.info.protocol,
            hostname: server.info.host,
            port: server.info.port,
            pathname: argparts.pathname,
            query: argparts.query
        },
        request = {
            url: url.format(parts)
        };
    server.log(['bench', 'injection', 'request'], request);
    server.inject(request, next);
}

function displayResponse(server, res, next) {
    server.log(['bench', 'injection', 'response'], {
        statusCode: res.statusCode,
        headers: res.headers
    });
    console.log(res.payload);
    next();
}

BenchTest.prototype.startAndInject = function startAndInject(path) {
    var self = this;

    this.start(function (err, server) {
        if (err) {
            throw err;
        }

        if (!path) {
            return; // server will keep loop going until killed
        }

        if (self.options.fixpath) {
            var fixedPath = self.options.fixpath(path);
            if (fixedPath && fixedPath !== path) {
                self.log(['bench', 'injection'], 'fixed path to: ' + fixedPath);
                path = fixedPath;
            }
        }

        injectRequest(server, path, function displayThenStopThenExit(res) {
            displayResponse(server, res, function stopThenExit() {
                self.stop(function exit(err) {
                    assert(!err);
                    process.exit(0);
                });
            });
        });
    });
};

BenchTest.prototype.main = function main() {
    var self = this;

    process.on('uncaughtException', function(err) {
        self.log(['bench', 'fatal'], {
            err: err,
            message: err.message,
            stack: err.stack ? err.stack.split('\n') : undefined
        });
    });

    var script = path.relative('.', process.argv[1]);

    if (process.argv.length > 3) {
        console.error('usage:', process.argv[0], script, '[ requestPath ]');
        process.exit(1);
    }

    this.startAndInject(process.argv[2]);
};

module.exports = BenchTest;

if (!module.parent) {
    (new BenchTest()).main();
}
